---
title: "Functions"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 4 tutorial"
---

<!-- Ch. 4 tutorial questions taken from rstudio-education/primers GitHub repo and list-column/mapping questions written by Evelyn Cai -->

<!-- EC: Insert countdown question elsewhere -->

```{r setup, include=FALSE}
library(tidyverse)
library(PPBDS.data)
library(learnr)
library(learnrhash)
library(shiny)
library(gapminder)
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
```

## Using map_* functions to create list columns

```{r name, echo=FALSE}
question_text(
  "Student Name:",
  answer(NULL, correct = TRUE),
  incorrect = "Ok",
  try_again_button = "Modify your answer",
  allow_retry = TRUE
)
```

<!-- EC: Insert one question about lists -->

```{r quiz-1}
quiz(caption = "Concept Check: Map functions and list-columns",
  question("What is a list-column?",
           answer("A list in which there is only one variable, and therefore only one \"column\""),
           answer("A list which only contains variable, or \"column\" names"),
           answer("A column of your data whose data type is a list rather than a character, numeric, integer, complex, or logical", message = "Remember, a list is not a data type, but rather a data structure! Other data structures include data frames and factors." ),
           answer("A column of your data which is a list rather than a vector", correct = TRUE),
           allow_retry = TRUE
  ),
  question("What does map_dbl() mean?",
           answer("The input to the map_dbl() function must be numeric", correct=TRUE),
           answer("The output of the map_dbl() function will be numeric"),
           allow_retry = TRUE
  ),
  question("How are map_* functions different than mutate()?",
           answer("They can take list inputs and iterate over each element of a list", correct = TRUE),
           answer("They are the same, except you can specify what output data type you'd like to have"),
           answer("They can apply functions to their inputs, whereas mutate() cannot"),
           answer("They can apply custom and anonymous functions to their inputs, whereas mutate() can only apply built-in functions to their inputs")),
   question("Which of the following is correct about map_* functions?",
           answer("You do not need the parentheses when specifying a function for the map_* function to apply. Ex: map(data, mean)", correct = TRUE),
           answer("You do need the parentheses when specifying a function for the map_* function to apply. Ex: map(data, mean())"),
           answer("You cannot have a list with NAs, or else using the map_* function will return an error", message = "This is not necessarily true. Hint: What does the \"...\" mean in map_*? Refer to the next question!")),
  question("What does the \"...\" argument mean in a map_* function?",
           answer("Nothing. R functions commonly have an auxiliary \"...\" argument"),
           answer("It means that the map_* function will take in its default arguments"),
           answer("It means that you can specify additional arguments to be passed into the given function", correct = TRUE))
)
```

List-Columns

### 

Create a list-column called `col_2` using `str_split()` that splits the phrases into "Government", "Data Science", "Preceptor", and "Primer".

```{r exercise-0, exercise = TRUE}
tibble(col_1 = c("Government and Data Science", "Preceptor and Primer")) %>%
  mutate(col_2 = ...) %>%
  str()
```

```{r exercise-0-hint}
tibble(col_1 = c("Government and Data Science", "Preceptor and Primer")) %>%
  mutate(col_2 = str_split(..., " and ")) %>%
  str()
```

Explore the `ChickWeight` dataset using `skim()`.

```{r exercise-1, exercise = TRUE}

```

```{r exercise-1-hint}
skim(...)
```

Create a list-column of weights using `mutate()`called `weight_groups`, grouping by `Diet` and `Time`. Save this list-column in a new dataframe called `x`.

```{r exercise-2, exercise = TRUE}
x <- ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(...)
```

```{r exercise-2-hint}
x <- ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(weight_groups = list(...))
```

Use a `map_*` function to find the mean weight per row in the new list-column. Name this new column `mean_weight`.

```{r setup3}
x <- ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(weight_groups = list(weight))
```

```{r exercise-3, exercise = TRUE, exercise.setup = "setup3"}
x <- x %>%
  mutate(mean_weight = map_dbl(...))
```

```{r exercise-3-hint}
x <- x %>%
  mutate(mean_weight = map_dbl(weight_groups, ...))
```

Now let's use `map_dbl()` to round each `mean_weight` to the nearest integer. Name this new column `rounded_mean`. 

```{r setup4, exercise.setup = "setup3"}
x <- x %>%
  mutate(mean_weight = map_dbl(weight_groups, mean))
```

```{r exercise-4, exercise = TRUE, exercise.setup = "setup4"}
x %>%
  mutate(rounded_mean = map_dbl(...))
```

```{r exercise-4-hint}
x %>%
  mutate(rounded_mean = map_dbl(mean_weight, ...))
```

```{r quiz-2}
quiz(
  question("What is the rounded mean weight for chicks given Diet 2 for 4 days (corresponding to a value of 4 in Time)?",
           answer("56 grams"),
           answer("41 grams"),
           answer("60 grams", correct = TRUE),
           answer("52 grams"),
           allow_retry = TRUE),
  question("What would have happened if we had used map() instead of map_dbl() above?",
           answer("The input would have looked for a list, rather than data of type double"),
           answer("Nothing. Map() is just the general function for all map functions"),
           answer("The output would have been a list, not a vector of type double", correct = TRUE, message = "Exactly! Try it out for yourself. This is why the world of map_* functions is so convenient. Functions such as unnest() can extract from list-columns, but there is no need to do so in this case."))
  )
```

Now let's use a `map_*` function to find the highest weight per `Diet` + `Time` combination. First, let's sort from highest to lowest weight and create a new column named `sorted_weight`.

```{r exercise-5, exercise = TRUE, exercise.setup = "setup4"}
x <- x %>%
  mutate(sorted_weight = map(weight_groups, ...))
```

```{r exercise-5-hint}
x <- x %>%
  mutate(sorted_weight = map(weight_groups, ..., decreasing = TRUE))
```

Next, return the highest weight in each row of the `sorted_weight` list-column in a new column named `heaviest`.

```{r setup6}
x <- x %>%
  mutate(sorted_weight = map(weight_groups, sort, decreasing = TRUE))
```

```{r exercise-6, exercise = TRUE, exercise.setup = "setup6"}
x %>%
  mutate(heaviest = map_dbl(...))
```

```{r exercise-6-hint}
x %>%
  mutate(heaviest = map_dbl(...,  ~ .[1]))
```

```{r quiz-3a}
quiz(
  question("What is the heaviest weight for a 16-day old chick on Diet 3?",
           answer("227 grams"),
           answer("287 grams", correct = TRUE),
           answer("222 grams"),
           answer("332 grams"))
)
```

## Built-In Functions and Custom Functions

```{r builtinfunctions}
quiz(
  question("Select all that apply: Which of the following operations requires running a function in R?",
           answer("Taking a log value", correct = TRUE),
           answer("Fitting a linear model", correct = TRUE),
           answer("Adding two numbers", correct = TRUE)),
  question("Which of the following is not a part of a function?",
         allow_retry = TRUE,
         random_answer_order = TRUE,
         answer("A name", correct = TRUE, message = "That's right, functions contain a code body, a set of formal arguments, and an environment, but not a name. They just happen to inherit a name from the object they are stored in."),
         answer("A code body", message = "Functions do require a code body! You can inspect this part of the function by using the helper function body()."),
         answer("A (potentially empty) set of formal arguments", message = "Functions do require formal arguments, even if they are empty! You can inspect this part of the function by using the helper function formals()."),
         answer("An environment", message = "Functions do require an environment, which is a self-contained space to look up the values of any objects within it. You can inspect this part of the function by using the helper function environment().")),
  question("Which of these will run the `Sys.time` function?",
         answer("Sys.time"),
         answer("Sys.time()", correct = TRUE, 
         message = "The open and closed parentheses tell R to execute the code in the code body of the function stored in the object names Sys.time.")),
  question("Suppose you need to run the following code on 20 different objects, `sqrt(sum(x^2))`. Why would you not want to rewrite the code 20 times? (Check all that apply)",
     answer("Retyping code takes time.", correct = TRUE),
     answer("Typing the code 20 times creates 20 chances to make a typo.", correct = TRUE),
     answer("If you need to change the code later, you'll need to change it in 20 different places.", correct = TRUE),
     allow_retry = TRUE, 
     type = "multiple", 
     incorrect = "Did you check ALL that applied?",
     correct = "Good job! You can avoid these outcomes by turning your code into a function. A good rule is to turn a piece of code into a function whenever you find yourself re-using the code more than three times."),
  question("What is the first step of writing a function?",
         answer("Choose a name, then type <- function(){", message = "You shouldn't type function() until you have code that works with a real test case."),
         answer("Create a real R object (or set of objects)", correct = TRUE, message = "You can then use the object to test your code."),
         answer("Assign argument names to your function"),
         answer("Write a help page that describes how your function will work."),
         allow_retry = TRUE))
```

Find the code body of `foo`

```{r foo, exercise = TRUE}
```

```{r foo-setup}
foo <- function() {
  a <- 10
  a
}
```

```{r foo-solution}
body(foo)
```

Recall the code in `foo`:

```{r echo = FALSE}
foo <- function() {
  a <- 10
  a
}
```

```{r}
body(foo)
```

What will be the final value of `a` if I run the following three lines of code in order?

```{r eval = FALSE}
a <- 1
foo()
a
```

```{r quiz-1b, echo = FALSE}
question("",
         answer("1", correct = TRUE, message = "What happens in a function, stays in the function. foo() will not change the value of a outside of foo()."),
         answer("10"),
         answer("Running a will return an error."),
         allow_retry = TRUE)
```

To make this real, put yourself in the shoes of a teacher: You've given your students 10 homework assignments and announced that you will drop their lowest homework score. Their final grade will be the average score of the remaining homeworks.

To make your life easier, you want to write an R function that will take a vector of 10 homework scores and return a final grade. 

1. Create a real R object (or set of objects) to use with your function

* Create an object named `x` that contains the vector `c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)` (hint: use copy and paste!). Then click Submit Answer. `x` will be the grades of your test student. 

```{r obj, exercise = TRUE}
```

```{r obj-solution}
x <- c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)
```

###  

2. Write code that works with the real object(s)

* Recall the grading scheme: the final grade is the average homework score after you drop the lowest score. Since there are many ways to calculate this, let's be specific and end up on the same page.

* Use `sum()`, `min()`, `/`, `9` and parentheses to calculate the final grade for student `x`. Click Submit Answer to check that your code works.

```{r make-x, echo = FALSE}
x <- c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)
```

```{r norm, exercise = TRUE, setup = "make-x"}
x
```

```{r norm-hint}
(sum(x) - min(x)) / ...
```

###  

Save the code below as a function named `grade`.

```{r grade, exercise = TRUE}
(sum(x) - min(x)) / 9
```

```{r grade-hint}
grade <- function() { 
  ...
}
```

###  

At the moment, your `grade()` function is reusable but not _generalizable_. Each time you call `grade()` it computes the final grade of the vector `x` that contains `c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)`. We'd like to use `grade()` with new vectors that have new values.

4. Assign the names of your real objects as argument names to the function.

You can make a function generalizable by turning some of the objects in its code body into _formal arguments_, an object that a user can assign a value to when they call the function.

Make `x` a formal argument.

```{r exercise-random-name, exercise=TRUE}
grade <- function() { 
  ...
}
```

```{r exercise-random-name-hint}
grade <- function(...) { 
  (sum(x) - min(x)) / 9
}
```

###   

Good job! You can now have a finished `grade()` function that you can use to calculate the final grade of _any_ vector (I mean, student). Try it out.

* Calculate the final grade of the vector `c(100, 90, 90, 90, 90, 90, 90, 90, 90, 80)`. Then click Submit Answer.

```{r make-grade}
grade <- function(x) { 
  (sum(x) - min(x)) / 9
}
```

```{r function, exercise = TRUE, exercise.setup = "make-grade"}
```

```{r function-solution}
grade(x = c(100, 90, 90, 90, 90, 90, 90, 90, 90, 80))
```

```{r recap, exercise=TRUE}
quiz(
  question("Which is not a step of the best practice workflow for writing functions?",
         allow_retry = TRUE, random_answer_order = TRUE,
         answer("Create a real R object (or set of objects) to use with your function"),
         answer("Write code that works with the real object(s)"),
         answer("Wrap the code in `function()`"),
         answer("Assign the names of your real objects as argument names to the function"),
         answer("Predict how the function should be written and try it out.", correct = TRUE)))
```

### Exercise 3

Let's write a function that grades by counting a student's highest score twice and then taking an average of the 11 scores.

```{r quiz-2c, echo = FALSE}
question("Do you have a test vector that you can use?",
         answer("Test vector? We don't need no stinking test vector.", 
                message = "Yes you do."),
         answer("Yes, we can reuse the vector named x.", correct=TRUE),
         allow_retry = TRUE,
         random_answer_order = TRUE)
```

###

* Write a piece of code that uses `max()` to double count the highest score in `x` and then takes the average of the 11 results. Click Submit Answer to check that your code works.

```{r e3, exercise = TRUE, exercise.setup = "make-x"}
x
```

```{r e3-hint}
"Your code should retrun the answer 99.09091."
```

```{r e3-solution}
(sum(x) + max(x)) / 11
```

* Wrap your code in `function()` and save it to the name `grade2`.
* Then define the argument(s) for the function.
* Then click Submit Answer.

```{r e4, exercise = TRUE}
(sum(x) + max(x)) / 11
```

```{r e4-hint}
"When you use this workflow, the names of the argument(s) are always the names of the object(s) that you created in step 1."
```

```{r e4-solution}
grade2 <- function(x) {
  (sum(x) + max(x)) / 11
}
```

## Argument Specifications and Default Values

```{r quiz-3b}
quiz(
  question("Select all that apply: Which of the following operations requires running a function in R?",
           answer("Taking a log value", correct = TRUE),
           answer("Fitting a linear model", correct = TRUE),
           answer("Adding two numbers", correct = TRUE)),
  question("Which of the following statements is NOT true about providing values for formal arguments in functions?",
           allow_retry= TRUE,
           random_answer_order = TRUE,
           answer("Never does the order that you provide formal arguments matter", correct = TRUE),
           answer("It is best practice to explicitly write out each argument name followed by an equal sign and its value"),
           answer("If you leave out argument names, R will match your values to arguments in the order that they are listed"),
           answer("If you do not provide a value and the function contains a default value, the default value is used")),
  question("Which method(s) can you use to match values to arguments? (Check all that apply.)",
         answer("Complete names (e.g. na.rm = TRUE)", correct = TRUE),
         answer("Partial names (e.g. na = TRUE)", correct = TRUE),
         answer("Numbers (e.g. 2 = TRUE)"),
         answer("Position (e.g. TRUE)", correct = TRUE),
         allow_retry = TRUE, type = "multiple", 
         incorrect = "Did you check _every_ method that works?",
         correct = "Good job! R can match values to arguments in three ways, but some of these methods are more foolproof then others."))
```

What will the following code return?

```{r eval = FALSE}
f <- function(a, b, c) {
  a
  b
  c
}
f(1, 2, 3)
```

```{r quiz-2b, echo = FALSE}
question("",
         answer("1"),
         answer("2"),
         answer("3", correct =TRUE, message = "A function will return the result of its *last* line."),
         answer("A vector that contains 1, 2, and 3"),
         answer("An error"),
         allow_retry = TRUE)
```

###

It's time to put it all together. 

* Use the code block below to develop a function named `l2` that calculates the Euclidean distance, or L~2~ norm ($\|x||_{2}$), of a vector of numbers named `x`. The L~2~ norm is the square root of the sum of the squared values in the vector, i.e.

$$\| x \|_{2} = \sqrt{\sum_{i = 1}^{n} x_{i}^{2}}$$

* When you are finished, reduce your code to just the definition of your function. Then click Submit Answer.

```{r e5, exercise = TRUE}
```

```{r e5-hint}
"Consider using sqrt(), sum(), and ^2. Your code will work with vectors of any length."
```

```{r e5-solution}
l2 <- function(x) {
  sqrt(sum(x^2))
}
```

### Default Values and Argument Positions

Consider this brilliant function:

```{r}
foo <- function(aaa, abb, abc) {
  c(aaa, abb, abc)
}
```

```{r no-args, echo = FALSE}
question("What will `foo()` return?",
         answer('[1] "aaa" "abb" "abc"'),
         answer("An error", correct = TRUE, message = "`foo` will not be able to find a value for `aaa` (or the rest)."),
         allow_retry = TRUE)
```

Let's make `foo` even more brilliant:

```{r}
foo <- function(aaa = 1, abb = 2, abc = 3) {
  c(aaa, abb, abc)
}
```

```{r default-args}
quiz(
  question("Now what will `foo()` return?",
         answer('[1] "aaa" "abb" "abc"'),
         answer('[1] 1 2 3', correct = TRUE, message = "An argument with a default value is optional, R will use the default value if you do not provide one."),
         answer("An error"),
         allow_retry = TRUE),
question("Which of these could you run to see the names and default values of `foo`'s arguments?",
         answer("`foo`"),
         answer("`?foo`"),
         answer("`formals(foo)`"),
         answer("`args(foo)`"),
         answer("All of the above.", correct = TRUE, message = "Each of these will return output that contains `foo`'s argument names and default values (somewhere in the output)."),
         incorrect = "Is that the only way?",
         allow_retry = TRUE),
question("What will `foo(0)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 2 3", correct = TRUE, message = "If you do not provide an argument name in your call, R will match your value to the first unmatched argument name."),
         answer("[1] 1 0 3"),
         answer("[1] 1 2 0"),
         answer("[1] 0 0 0"),
         answer("An error"),
         allow_retry = TRUE),
question("What will `foo(0, 5)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 5 3", correct = TRUE, message = "I think you have the hang of position matching."),
         answer("[1] 0 5 0"),
         answer("[1] 0 5 5"),
         answer("An error"),
         allow_retry = TRUE),
question("What will `foo(aaa = 0, abc = 5)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 5 3"),
         answer("[1] 0 5 0"),
         answer("[1] 0 2 5", correct = TRUE, message = "Using complete argument names is the easiest way to avoid an error (and to write comprehensible code). But what if you use a partial argument name?"),
         answer("An error"),
         allow_retry = TRUE),
question("What will `foo(aa = 0)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 2 3", correct = TRUE, message = "You do not need to spell out the full argument name, so long as you provide enough of the name to uniquely identify the argument. Here `aa` could only be the beginning of the `aaa` argument."),
         answer("[1] 0 0 0"),
         answer("An error"),
         allow_retry = TRUE),
question("What will `foo(a = 0)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 2 3"),
         answer("[1] 0 0 0"),
         answer("An error", correct = TRUE, message = "Here `a` does not uniquely match an argument name: it is the beginning of all three argument names. R isn't psychic, so it won't guess which argument you meant. Instead R returns an error. It's the right thing to do because it lets you fix your code."),
         allow_retry = TRUE))
```

###

Now for some dark magic:

```{r}
foodoo <- function(...) {
  c(...)
}
```

```{r dots-1, echo = FALSE}
quiz(
  question("What will `foodoo(1, 2, 3)` return?",
         answer("[1] 1 2 3", correct = TRUE, message = "`...` is a special mechanism for passing arguments. `...` will match any argument not otherwise matched and pass those arguments on as a group. This is a convenient way to pass a set of arguments through to a function in the function body."),
         answer("An error."),
         answer("Oh my goodness! You've broken R!"),
         allow_retry = TRUE),
question("What will `foodoo(a = 1, b = 2, c = 3)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 1 2 3 _but with the names a b c above the values_", correct = TRUE, message = "If you provide names to your values, `...` will capture those as well and pass them on. So here, our code essentially runs `c(a = 1, b = 2, c = 3)`."),
         answer("An error."),
         allow_retry = TRUE))
```

###  

Here is one last wrinkle. Suppose we rewrite `foodoo` slightly:

```{r}
foodoo <- function(a, ...) {
  c(...)
}
```

```{r dots-3, echo = FALSE}
quiz(
  question("What will `foodoo(a = 1, b = 2, c = 3)` return?",
         answer("[1] 1 2 3 with the names a b c above the values"),
          answer("[1] 2 3 with the names b c above the values", correct = TRUE, message = "Remember that `...` only captures _unmatched_ values. Now that `a` is a formal argument, `a = 1` will be matched to it, leaving `b = 2` and `c = 3` to be captured and passed on."),
         answer("An error."),
         allow_retry = TRUE))
```

### Environments

Thanks to the previous tutorials, you can write and execute functions, but can you predict how a function will work? 

To do that precisely, you need to know how R will look up the values of objects that appear in the function.

Consider the code below, which defines and then calls the function `foo()`. With its last line, `foo()` returns the value of `z`, but what will the value be?

```{r eval = FALSE}
z <- 1
foo <- function(z = 2) {
  z <- 3
  z
}
foo(z = 4)
```

```{r q1-environments, echo = FALSE}
question("What will the value of `z` be?",
         answer("`1`, because we define `z <- 1` before defining the function."),
         answer("`2`, because `2` is the default value of the `z` argument."),
         answer("`3`, because the function runs `z <- 3`", correct = TRUE, message = "R can look for the value of z in many places, so it is important to know where R will look and why."),
         answer("`4`, because we define `z = 4` when we call the function."),
         allow_retry = TRUE, 
         incorrect = "Not Quite.")
```

## Formal Testing

### Checks using `stopifnot()`, and `stop()`

```{r return-quiz, echo = FALSE}
quiz(
  question("Which value will `impatient_square(2)` return?",
         answer("2", correct = TRUE, message = "R stops executing `impatient_square()` and returns `x` when R encounters `return(x)`. It doesn't matter that `return(x)` is not the last line of the function."),
         answer("4", message = "R stops executing `impatient_square()` when it encounters `return(x)`. As a result, R does not evaluate `x^2`."),
         allow_retry = TRUE),
  question("When should you use return()?",
           answer("Whenever you want your function to return a value from the last line of the code body", message = "Remember, R functions automatically return the last value."),
           answer("Whenever you want to return a value that is not the last line of the code body", correct = TRUE, message = "Correct! This can either be for diagnosis purposes when debugging or for unusual control flow cases in general"),
           allow_retry = TRUE))
```

`stop()` behaves like `return()`, but instead of returning a value, `stop()` returns an error, complete with a custom error message. Can you tell how it works?

```{r eval = FALSE, echo=TRUE}
immovable_square <- function(x) {
  stop("I refuse to proceed.")
  x^2
}
```

```{r stop-quiz, echo = FALSE}
question("What does `immovable_square(2)` return?",
         answer("4", message = 'R will stop executing `immovable_square()` and throw an error when it comes to `stop("I refuse to proceed.")`.'),
         answer("Error in immovable_square(2) : I refuse to proceed.", correct = TRUE, message = 'R will stop executing `immovable_square()` and throw an error when it comes to `stop("I refuse to proceed")`. The error message will look just like this answer; R inserts the message that you pass as a character string to `stop()`.'),
         allow_retry = TRUE)
```

## Using map_* functions and custom/anonymous functions to create list-columns

### Conditional Functions

```{r if-quiz, echo = FALSE}
question("Which describes `if`'s behavior? (Check all that apply).",
         answer("`if` takes a logical test and a piece of code. It runs the code _if_ the test returns TRUE.", correct = TRUE, message = "`if` is a way to run code only in certain cases. When you use `if`, you first pass it a logical test surrounded by parentheses and then a piece of code."),
         answer("`if` takes a logical test and a piece of code. It does not run the code _if_ the logical test returns FALSE.", correct = TRUE, message = "`if` will run the piece of code if the logical test returns TRUE and not run the code if the logical test returns FALSE."),
         answer("`if` returns the results of the code that appears in _parentheses_ behind `if`."),
         answer("`if` always executes all of the code that follows it.", message = "`if` will always execute the logical test that appears in parentheses behind `if`. However, `if` will only execute the code that appears after the logical test if the logical test returns TRUE."),
         allow_retry = TRUE)
```

Many data sets use their own symbols to represent missing values. For example, NOAA will often use -99 to represent missing values in weather data sets. Let's write a function that checks whether a value is -99, and if so replaces the value with NA, like this:

```{r echo = FALSE}
clean <- function(x) {
  if (x == -99) x <- NA
  x
}
```

```{r}
clean(1)
clean(-99)
```

###  

Add an `if` statement to the beginning of `clean()`. Your statement should assign NA to x if x equals -99. Then click Submit Answer.

```{r clean-setup}
x <- -99
```

```{r clean, exercise = TRUE}
clean <- function(x) {
  # add if statement here
  x
}
```

```{r clean-solution}
clean <- function(x) {
  if (x == -99) x <- NA
  x
}
```

###

Here is a second version of `clean()` that uses on a new command. Can you tell what `else` does?  Run `clean()` with several different values, `22`, `-99`, `3`. What does `clean()` return in each case?

```{r echo=TRUE}
clean <- function(x) {
  if (x == -99) NA else x
}
```

```{r else-setup}
clean <- function(x) {
  if (x == -99) NA 
  else x
}
```

```{r else, exercise = TRUE}
```

###  

```{r else-quiz, echo = FALSE}
question("Which describes `else`? (Check all that apply).",
         answer("R interprets `else` as a continuation of the `if` statement that immediately precedes it.", correct = TRUE, message = "`else` always follows an `if` statement (if not, `else` returns an error), and R always sees the combined `if` and `else` statements as a single statement."),
         answer("Unlike `if`, `else` does not take a logical test.", correct = TRUE),
         answer("Like `if`, `else` takes a piece of code.", correct = TRUE),
         answer("`else` executes the piece of code if the `if` condition returns FALSE.", correct = TRUE),
         answer("`else` does not execute the piece of code if the `if` condition returns TRUE.", correct = TRUE, message = "Think of a combined `if` `else` statement as a complete description: if the logical test at the start of the statement returns TRUE, R will run the code that follows `if` (but not the code that follows `else`). If the condition returns FALSE, R will run the code that follows `else` (but not the code that follows `if`)."),
         allow_retry = TRUE)
```

SAS often saves missing values as `"."`.

* Write a function named `clean2` that takes a value named `x` and returns an NA if the value is `"."` (and returns the value of `x` otherwise).

```{r clean2-setup}
x <- "."
```

```{r clean2, exercise = TRUE}
```

```{r clean2-solution}
clean <- function(x) {
  if (x == ".") NA 
  else x
}
```

* Write a function named `clean()` that uses `if`, `else`, and `else if` statements to replace the following four values with NA before returning x, `-99`, `"."`, `""`, `"NaN"`. Then click Submit Answer.

```{r clean3-setup}
x <- ""
```


```{r clean3, exercise = TRUE}
```

```{r clean3-solution}
clean <- function(x) {
  if (x == -99) NA 
  else if (x == ".") NA
  else if (x == "") NA
  else if (x == "NaN") NA
  else x
}
```

### Combining `stopifnot()` and  conditional statements

Use `if` and `is.null()` to add a `stop()` call at the beginning of `clean()`. The command should return the error message `"x is NULL"` whenever x is NULL. 

```{r stop, exercise = TRUE}
clean <- function(x) {
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stop-solution}
clean <- function(x) {
  if (is.null(x)) stop("x is NULL")
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stopifnot-quiz, echo = FALSE}
quiz(
  question('Which of these does the equivalent of `if (x < 0) stop("x is less than zero")`?',
         answer('`stopifnot(x < 0)`', message = "Good guess! But the function isn't called `stopif()`; it's called `stopifnot()`."),
         answer('`stopifnot(x >= 0)`', correct = TRUE, message = "`stopifnot()` stops if a condition is _not_ met, which is slightly different than `if` + `stop()`."),
         allow_retry = TRUE),
  question("How is stopifnot() different from if` + stop()?",
           allow_retry = TRUE,
           random_answer_order = TRUE,
           answer("Instead of checking whether a condition is met, `stopifnot()` checks whether a condition is not met", correct = TRUE),
           answer("stopifnot() always passes along a custom error message"),
           answer("stopifnot() cannot take logical arguments")))
```

###  

Replace the `if` + `stop()` statement in `clean()` with `stopifnot()`. Then click Submit Answer.

```{r stopifnot, exercise = TRUE}
clean <- function(x) {
  if (is.null(x)) stop("x is NULL")
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stopifnot-solution}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

###

Rewrite the below function using `case_when()`.

```{r echo = TRUE}
foo <- function(x) {
  if (x > 2) "a"
  else if (x < 2) "b"
  else if (x == 1) "c"
  else "d"
}
```

```{r foo_rewrite, exercise = TRUE}
foo2 <- function(x) {
  case_when(
    
    # Insert code here!
    
  )
}
```

```{r foo_rewrite-hint-1}
foo2 <- function(x) {
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    ...
  )
}
```

```{r foo_rewrite-hint-2}
foo2 <- function(x) {
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    x == 1 ~ "c",
    TRUE ~ ...
  )
}
```

###

Rewrite the multi-part version of `clean()` to use `case_when()`, which will allow `clean()` to handle vectors. Retain each case. Assume where necessary that `clean()` will only work with real numbers.

```{r when, exercise = TRUE}
clean <- function(x) {
  if (x == -99) NA 
  else if (x == ".") NA
  else if (x == "") NA
  else if (x == "NaN") NA
  else x
}
```

```{r when-hint}
clean <- function(x) {
  case_when(
    x == -99 ~ NA_real_, 
    x == "." ~ NA_real_,
    x == "" ~ NA_real_,
    x == "NaN" ~ NA_real_,
    TRUE ~ ...
  )
}
```

###

```{r eval = FALSE, echo = TRUE}
foo <- function(x) {
  if (x > 2) "a"
  else if (x < 2) "b"
  else if (x == 1) "c"
  else "d"
}
foo(1)
```

```{r else-if-quiz, echo = FALSE}
quiz(
  question("What will this code return?",
         answer('"a"', message = "R will not return a because the condition 1 > 2 is false."),
         answer('"b"', correct = TRUE, message = 'The condition 1 < 2 is true, so R will evaluate the code that follows it (i.e. "b") and then skip the remainder of the multi-part if statement.'),
         answer('"a" "b"', message = "The conditions 1 < 2 and 1 == 1 are both TRUE, but R will stop after the _first_ true condition."),
         allow_retry = TRUE))
```

###

```{r eval = FALSE, echo=TRUE}
clean <- function(x) {
  if (x == -99) NA 
  if (x == ".") NA
  if (x == "NaN") NA
  x
}
clean(-99)
```

```{r clean3-quiz, echo = FALSE}
quiz(
  question("What will this code return?",
         answer("NA", message = "Did you notice that the `if` statements are not linked by `else`? What difference does this make?"),
         answer("-99", correct = TRUE, message = "Since the `if` clauses are not linked by `else`, R treats them as separate statements. R checks each if statement. After the first statement it runs NA, but does not return this as the result of the function (because this is not the final statement in the function). R does not run NA for the next two if statements because their conditions are false. Then R reaches `x`, which is the last line and last statement in the function. R evaluates `x`, which equals -99, and returns -99 as the result of the function."),
         allow_retry = TRUE))
```


Replace the two `if` statements below with a single statement that tests whether x is `-99` or `"."` without throwing error messages.

```{r or, exercise = TRUE}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  x
}
```

```{r or-hint}
"Like |, || expects a _complete_ logical test on each side of ||."
```

```{r or-solution}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99 || x == ".") return(NA)
  x
}
```

###  

```{r eval = FALSE, echo= TRUE}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99 || x == ".") return(NA)
  x
}
```

```{r vector-quiz, echo = FALSE}
question("What will `clean(c(-99, 0, 1))` return?",
         answer("NA 0 1", message = "The logical test will only consider the first value of the vector x, which here contains c(-99, 0, 1). Since that value is -99, the logical test will return TRUE and R will execute the code `return(NA)`, which returns a single NA."),
         answer("NA _with_ a warning message", message = "You certainly would get a warning message if your logical test used |, which will pass a vector of TRUEs and FALSEs to if, triggering the message. However, || will only pass on a single TRUE or FALSE."),
         answer("NA _without_ a warning message", correct = TRUE),
         answer("an error"),
         allow_retry = TRUE)
```

Explore the `airquality` dataset using `skim()`.

```{r exercise-1a, exercise = TRUE}

```

```{r exercise-1a-hint}
skim(...)
```

Create a list-column of monthly temperatures called `monthly_temp`, grouping by `Month`. Save this new list-column in a dataframe called `y`.

```{r exercise-2a, exercise = TRUE}

```

```{r exercise-2a-hint}
# y <- airquality %>%
#   group_by(Month) %>%
#   mutate(monthly_temp = list(...))
```

```{r quiz-4}
quiz(caption = "mutate(celsius = map(fahrenheit, ...)",
  question("Which of the following possibilities for filling in the blank is syntactically correct and converts from Fahrenheit to Celsius?",
           answer("(. - 32) * 5/9)"),
           answer("- 32 * 5/9"),
           answer("~ (. - 32) * 5/9)", correct = TRUE),
           answer("~ (fahrenheit - 32) * 5/9)"))
)
```

Use a `map_*` function to convert all of the temperatures in `monthly_temp` from Fahrenheit to Celsius, creating a new variable `temp_celsius`. Hint: Use the formula from the quiz above!

```{r exercise-3a-setup}
y <- airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp))
```

```{r exercise-3a, exercise = TRUE}
y <- y %>%
  mutate(temp_celsius = map(...))
```

```{r exercise-3a-hint}
y <- y %>%
  mutate(temp_celsius = map(monthly_temp, ...))
```

Oops! The scientists made a mistake in which all of the temperatures were misrecorded. For temperatures recorded at or below 20 degrees Celsius, the true temperature is actually 1 degree Celsius lower. For temperatures recorded as higher than 20 degrees Celsius, the true temperature is actually 3 degrees Celsius higher.

Write an anonymous function using base R that rectifies the scientists' mistake using `case_when()`.

```{r exercise-4a, exercise=TRUE}
function(x) 
  case_when(...)
```

```{r exercise-4a-solution}
function(x) 
  case_when(x <= 20 ~ x - 1,
            x > 20 ~ x + 3)
```

Now use this function along with `map()`, swapping out the base R for the `~` in the `map()` argument.

```{r setup5a}
y <- y %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9))
```

```{r exercise-5a, exercise=TRUE, exercise.setup = "setup5a"}
y <- y %>%
  mutate(temp_celsius = map(temp_celsius, ~ ...))
```

```{r exercise-5a-hint}
y %>%
  mutate(temp_celsius = map(temp_celsius, ~ case_when(...)))
```

Now let's get a sense of the "corrected" data. Sort the temperatures from coldest to hottest each month.

```{r exercise-6a, exercise=TRUE, exercise.setup = "setup5a"}

```

```{r exercise-6a-hint}
y %>%
  mutate(temp_celsius = map(temp_celsius, ~ sort(case_when(...))))
```

```{r quiz-5}
quiz(
  question("What is the coldest temperature in July?",
           answer("25.78 degrees Celsius", correct = TRUE),
           answer("30.33 degrees Celsius"),
           answer("12.33 degrees Celsius"),
           answer("26.33 degrees Celsius"))
)
```

Let's reference the `gapminder` dataset. First, create a list-column named `gdpPercap_yearly` that lists the `gdpPercap` per year grouping by continent.

```{r exercise-7a, exercise=TRUE}

```

```{r exercise-7a-hint}
gapminder %>%
  group_by(year, continent) %>%
  mutate(gdpPercap_yearly = list(...))
```

Now, build upon the previous question's code and, instead of taking the `gdpPercap`, calculate the *total wealth of the country in that year*. Save this as a new dataframe named `wealth`.

```{r exercise-8a, exercise=TRUE}

```

```{r exercise-8a-hint}
wealth <- gapminder %>%
  group_by(year, continent) %>%
  mutate(gdpPercap_yearly = list(gdpPercap * ...))
```

## Submit

```{r encode, echo=FALSE}
learnrhash::encoder_ui(
  ui_before = shiny::div(
    "When you have completed this tutorial, follow these steps:",
        br(),
    tags$ol(
       tags$li("Click Generate Submission"),
       tags$li("Copy and paste the hash generated into the \"Hash\" textbox"),
       tags$li("Press 'Create responses.rds'. Nothing will pop up, but this will create an .rds file of your hashed responses."),
       tags$li("Download the .rds file. A window will pop up asking you where to place the downloaded file. Upload this file to the appropriate Canvas assignment."))
  )
)
```

```{r context="setup"}
fluidPage(
    mainPanel(
          div(id = "form",
            textInput("hash", "Hash", ""),
            actionButton("submit", "Create responses.rds", class = "btn-primary"),
            downloadButton("downloadData", "Download responses.rds")
          )
        )
    )
```

```{r context="server"}

learnrhash::encoder_logic()

 observeEvent(input$submit,{
        hash_id <<- input$hash
        responses <<- data.frame("Hash" = hash_id)
 })
output$downloadData <- downloadHandler(
      filename = "responses.rds",
      content = function(file) {
      write_rds(responses, file)
    }
  )
```
