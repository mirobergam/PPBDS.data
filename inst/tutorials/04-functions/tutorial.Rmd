---
title: "Functions"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 4 tutorial"
---

<!-- Ch. 4 tutorial questions taken from rstudio-education/primers GitHub repo and list-column/mapping questions written by Evelyn Cai -->

<!-- EC: Insert countdown question elsewhere -->

```{r setup, include=FALSE}
library(tidyverse)
library(PPBDS.data)
library(learnr)
library(learnrhash)
library(shiny)
library(gapminder)
knitr::opts_chunk$set(echo = FALSE, message = FALSE)
```

## Introduction to Functions

```{r name, echo=FALSE}
question_text(
  "Student Name:",
  answer(NULL, correct = TRUE),
  incorrect = "Ok",
  try_again_button = "Modify your answer",
  allow_retry = TRUE
)
```

```{r firstquiz}
quiz(caption = "Concept Check: Function Basics",
  question("Select all that apply: Which of the following operations requires running a function in R?",
           answer("Taking a log value", correct = TRUE),
           answer("Fitting a linear model", correct = TRUE),
           answer("Adding two numbers", correct = TRUE)),
  question("Which of the following is not a part of a function?",
         allow_retry = TRUE,
         random_answer_order = TRUE,
         answer("A name", correct = TRUE, message = "That's right, functions contain a code body, a set of formal arguments, and an environment, but not a name. They just happen to inherit a name from the object they are stored in."),
         answer("A code body", message = "Functions do require a code body! You can inspect this part of the function by using the helper function body()."),
         answer("A (potentially empty) set of formal arguments", message = "Functions do require formal arguments, even if they are empty! You can inspect this part of the function by using the helper function formals()."),
         answer("An environment", message = "Functions do require an environment, which is a self-contained space to look up the values of any objects within it. You can inspect this part of the function by using the helper function environment().")),
  question("Suppose you need to run the following code on 20 different objects, `sqrt(sum(x^2))`. Why would you not want to rewrite the code 20 times? (Check all that apply)",
     answer("Retyping code takes time.", correct = TRUE),
     answer("Typing the code 20 times creates 20 chances to make a typo.", correct = TRUE),
     answer("If you need to change the code later, you'll need to change it in 20 different places.", correct = TRUE),
     allow_retry = TRUE, 
     type = "multiple", 
     incorrect = "Did you check ALL that applied?",
     correct = "Good job! You can avoid these outcomes by turning your code into a function. A good rule is to turn a piece of code into a function whenever you find yourself re-using the code more than three times."),
    question("Which of these will run the `Sys.time` function?",
         answer("Sys.time"),
         answer("Sys.time()", correct = TRUE, 
         message = "The open and closed parentheses tell R to execute the code in the code body of the function stored in the object names Sys.time.")))
```

Find the code body of `foo`. Use the helper function `body()`.

```{r foo, exercise = TRUE}
```

```{r foo-setup}
foo <- function() {
  a <- 10
  a
}
```

```{r foo-hint}
# body(...)
```

## Using map_* functions to create list columns

<!-- EC: Insert one question about lists -->

```{r quiz-1}
quiz(caption = "Concept Check: Map functions and list-columns",
  question("What is a list-column?",
           answer("A list in which there is only one variable, and therefore only one \"column\""),
           answer("A list which only contains variable, or \"column\" names"),
           answer("A column of your data whose data type is a list rather than a character, numeric, integer, complex, or logical", message = "Remember, a list is not a data type, but rather a data structure! Other data structures include data frames and factors." ),
           answer("A column of your data which is a list rather than a vector", correct = TRUE),
           allow_retry = TRUE
  ),
  question("What does map_dbl() mean?",
           answer("The input to the map_dbl() function must be numeric", correct=TRUE),
           answer("The output of the map_dbl() function will be numeric"),
           allow_retry = TRUE
  ),
  question("How are map_* functions different than mutate()?",
           answer("They can take list inputs and iterate over each element of a list", correct = TRUE),
           answer("They are the same, except you can specify what output data type you'd like to have"),
           answer("They can apply functions to their inputs, whereas mutate() cannot"),
           answer("They can apply custom and anonymous functions to their inputs, whereas mutate() can only apply built-in functions to their inputs")),
   question("Which of the following is correct about map_* functions?",
           answer("You do not need the parentheses when specifying a function for the map_* function to apply. Ex: map(data, mean)", correct = TRUE),
           answer("You do need the parentheses when specifying a function for the map_* function to apply. Ex: map(data, mean())"),
           answer("You cannot have a list with NAs, or else using the map_* function will return an error", message = "This is not necessarily true. Hint: What does the \"...\" mean in map_*? Refer to the next question!")),
  question("What does the \"...\" argument mean in a map_* function?",
           answer("Nothing. R functions commonly have an auxiliary \"...\" argument"),
           answer("It means that the map_* function will take in its default arguments"),
           answer("It means that you can specify additional arguments to be passed into the given function", correct = TRUE))
)
```

### 

Create a list-column called `col_2` using `str_split()` that splits the phrases into "Government", "Data Science", "Preceptor", and "Primer".

```{r exercise-0, exercise = TRUE}
tibble(col_1 = c("Government and Data Science", "Preceptor and Primer")) %>%
  mutate(col_2 = ...) %>%
  str()
```

```{r exercise-0-hint}
tibble(col_1 = c("Government and Data Science", "Preceptor and Primer")) %>%
  mutate(col_2 = str_split(..., " and ")) %>%
  str()
```

###

Explore the `ChickWeight` dataset using `skim()`.

```{r exercise-1, exercise = TRUE}

```

```{r exercise-1-hint}
skim(...)
```

Create a list-column of weights using `mutate()`called `weight_groups`, grouping by `Diet` and `Time`. Save this list-column in a new dataframe called `x`.

```{r exercise-2, exercise = TRUE}
x <- ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(...)
```

```{r exercise-2-hint}
x <- ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(weight_groups = list(...))
```

Use a `map_*` function to find the mean weight per row in the new list-column. Name this new column `mean_weight`.

```{r setup3}
x <- ChickWeight %>%
  group_by(Diet, Time) %>%
  mutate(weight_groups = list(weight))
```

```{r exercise-3, exercise = TRUE, exercise.setup = "setup3"}
x <- x %>%
  mutate(mean_weight = map_dbl(...))
```

```{r exercise-3-hint}
x <- x %>%
  mutate(mean_weight = map_dbl(weight_groups, ...))
```

Now let's use `map_dbl()` to round each `mean_weight` to the nearest integer. Name this new column `rounded_mean`. 

```{r setup4, exercise.setup = "setup3"}
x <- x %>%
  mutate(mean_weight = map_dbl(weight_groups, mean))
```

```{r exercise-4, exercise = TRUE, exercise.setup = "setup4"}
x %>%
  mutate(rounded_mean = map_dbl(...))
```

```{r exercise-4-hint}
x %>%
  mutate(rounded_mean = map_dbl(mean_weight, ...))
```

```{r quiz-2}
quiz(
  question("What is the rounded mean weight for chicks given Diet 2 for 4 days (corresponding to a value of 4 in Time)?",
           answer("56 grams"),
           answer("41 grams"),
           answer("60 grams", correct = TRUE),
           answer("52 grams"),
           allow_retry = TRUE),
  question("What would have happened if we had used map() instead of map_dbl() above?",
           answer("The input would have looked for a list, rather than data of type double"),
           answer("Nothing. Map() is just the general function for all map functions"),
           answer("The output would have been a list, not a vector of type double", correct = TRUE, message = "Exactly! Try it out for yourself. This is why the world of map_* functions is so convenient. Functions such as unnest() can extract from list-columns, but there is no need to do so in this case."))
  )
```

###

Now let's use a `map_*` function to find the highest weight per `Diet` + `Time` combination. First, let's sort from highest to lowest weight and create a new column named `sorted_weight`.

```{r exercise-5, exercise = TRUE, exercise.setup = "setup4"}
x <- x %>%
  mutate(sorted_weight = map(weight_groups, ...))
```

```{r exercise-5-hint}
x <- x %>%
  mutate(sorted_weight = map(weight_groups, ..., decreasing = TRUE))
```

Next, return the highest weight in each row of the `sorted_weight` list-column in a new column named `heaviest`.

```{r setup6}
x <- x %>%
  mutate(sorted_weight = map(weight_groups, sort, decreasing = TRUE))
```

```{r exercise-6, exercise = TRUE, exercise.setup = "setup6"}
x %>%
  mutate(heaviest = map_dbl(...))
```

```{r exercise-6-hint}
x %>%
  mutate(heaviest = map_dbl(...,  ~ .[1]))
```

```{r quiz-3a}
quiz(
  question("What is the heaviest weight for a 16-day old chick on Diet 3?",
           answer("227 grams"),
           answer("287 grams", correct = TRUE),
           answer("222 grams"),
           answer("332 grams"))
)
```

###

Let's reference the `gapminder` dataset. First, create a list-column named `gdpPercap_yearly` that lists the `gdpPercap` per year grouping by continent.

```{r exercise-7a, exercise=TRUE}

```

```{r exercise-7a-hint}
gapminder %>%
  group_by(year, continent) %>%
  mutate(gdpPercap_yearly = list(...))
```

###

Now, build upon the previous question's code and, instead of taking the `gdpPercap`, calculate the *annual GDP of the country* in a new variable called `annual_gdp`.

```{r exercise-8a, exercise=TRUE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(...))
```

```{r exercise-8a-hint}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * ...))
```

###

What was the lowest GDP in each `year` x `continent` category? Create a new column named `lowest` of data type "double" that contains the lowest GDP per year/continent. Pay attention to the `map_*` function you use.

```{r exercise-9a, exercise=TRUE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(lowest = ...)
```

```{r exercise-9a-hint}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(lowest = map_dbl(annual_gdp, ...))
```

###

What was the lowest GDP for a country in the Americas in 1992?

```{r exercise-10a, exercise = TRUE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(lowest = map_dbl(annual_gdp, min))
```

```{r exercise-10a-hint, exercise = TRUE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(lowest = map_dbl(annual_gdp, min)) %>%
  filter(...)
```

```{r wealthmin}
quiz(
  question("What was the lowest GDP for a South American country in 1992?",
         answer("Choose a name, then type <- function(){", message = "You shouldn't type function() until you have code that works with a real test case."),
         answer("$8,719,537,248", correct = TRUE),
         answer("$4,353,422,616"),
         answer("$6,567,086,330"),
         answer("$4,129,281,353"),
         allow_retry = TRUE,
         random_answer_order = TRUE))
```

###

Now let's examine what the highest GDP was per year/continent. Create a new column named `highest` of data type "double" that contains the lowest GDP per year/continent. Pay attention to the `map_*` function you use.

```{r exercise-11a, exercise=TRUE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(highest = ...)
```

```{r exercise-11a-hint}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(highest = map_dbl(annual_gdp, ...))
```

###

What was the highest GDP for an African country in 2007?

```{r exercise-12a, exercise = TRUE}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(highest = map_dbl(annual_gdp, max))
```

```{r exercise-12a-hint}
gapminder %>%
  group_by(year, continent) %>%
  mutate(annual_gdp = list(gdpPercap * pop)) %>%
  mutate(highest = map_dbl(annual_gdp, max)) %>%
  filter(...)
```

```{r wealthmax}
quiz(
  question("What was the highest GDP for an African country in 2007?",
         answer("$2,204,242,423,150"),
         answer("$447,970,942,205", correct = TRUE),
         answer("$6,539,500,929,092"),
         answer("$67,406,033,606"),
         allow_retry = TRUE,
         random_answer_order = TRUE))
```

## Built-In Functions and Custom Functions

```{r builtinfunctions}
quiz(
  question("What is the first step of writing a function?",
         answer("Choose a name, then type <- function(){", message = "You shouldn't type function() until you have code that works with a real test case."),
         answer("Create a real R object (or set of objects)", correct = TRUE, message = "You can then use the object to test your code."),
         answer("Assign argument names to your function"),
         answer("Write a help page that describes how your function will work."),
         allow_retry = TRUE))
```

```{r foo-solution}
body(foo)
```

Recall the code in `foo`:

```{r echo = FALSE}
foo <- function() {
  a <- 10
  a
}
```

```{r}
body(foo)
```

What will be the final value of `a` if I run the following three lines of code in order?

```{r eval = FALSE}
a <- 1
foo()
a
```

```{r quiz-1b, echo = FALSE}
quiz(
  question("",
         answer("1", correct = TRUE, message = "What happens in a function, stays in the function. foo() will not change the value of a outside of foo()."),
         answer("10"),
         answer("Running a will return an error."),
         allow_retry = TRUE))
```

To make this real, put yourself in the shoes of a teacher: You've given your students 10 homework assignments and announced that you will drop their lowest homework score. Their final grade will be the average score of the remaining homeworks.

To make your life easier, you want to write an R function that will take a vector of 10 homework scores and return a final grade. 

1. Create a real R object (or set of objects) to use with your function

* Create an object named `x` that contains the vector `c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)` (hint: use copy and paste!).  `x` will be the grades of your test student. 

```{r obj, exercise = TRUE}
```

```{r obj-solution}
x <- c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)
```

###  

2. Write code that works with the real object(s)

* Recall the grading scheme: the final grade is the average homework score after you drop the lowest score. Since there are many ways to calculate this, let's be specific and end up on the same page.

* Use `sum()`, `min()`, `/`, `9` and parentheses to calculate the final grade for student `x`.

```{r make-x, echo = FALSE}
x <- c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)
```

```{r norm, exercise = TRUE, setup = "make-x"}
x
```

```{r norm-hint}
(sum(x) - min(x)) / ...
```

###  

Save the code below as a function named `grade`.

```{r grade, exercise = TRUE}
(sum(x) - min(x)) / 9
```

```{r grade-hint}
grade <- function() { 
  ...
}
```

###  

At the moment, your `grade()` function is reusable but not _generalizable_. Each time you call `grade()` it computes the final grade of the vector `x` that contains `c(100, 100, 100, 100, 100, 100, 100, 100, 100, 90)`. We'd like to use `grade()` with new vectors that have new values.

4. Assign the names of your real objects as argument names to the function.

You can make a function generalizable by turning some of the objects in its code body into _formal arguments_, an object that a user can assign a value to when they call the function.

Make `x` a formal argument.

```{r exercise-random-name, exercise=TRUE}
grade <- function() { 
  ...
}
```

```{r exercise-random-name-hint}
grade <- function(...) { 
  (sum(x) - min(x)) / 9
}
```

###   

Good job! You can now have a finished `grade()` function that you can use to calculate the final grade of _any_ vector (I mean, student). Try it out.

* Calculate the final grade of the vector `c(100, 90, 90, 90, 90, 90, 90, 90, 90, 80)`. 

```{r make-grade}
grade <- function(x) { 
  (sum(x) - min(x)) / 9
}
```

```{r function, exercise = TRUE, exercise.setup = "make-grade"}
```

```{r function-solution}
grade(x = c(100, 90, 90, 90, 90, 90, 90, 90, 90, 80))
```

```{r recap}
quiz(
  question("Which is not a step of the best practice workflow for writing functions?",
         allow_retry = TRUE, random_answer_order = TRUE,
         answer("Create a real R object (or set of objects) to use with your function"),
         answer("Write code that works with the real object(s)"),
         answer("Wrap the code in `function()`"),
         answer("Assign the names of your real objects as argument names to the function"),
         answer("Predict how the function should be written and try it out.", correct = TRUE)))
```

### Exercise 3

Let's write a function that grades by counting a student's highest score twice and then taking an average of the 11 scores.

```{r quiz-2c, echo = FALSE}
question("Do you have a test vector that you can use?",
         answer("Test vector? We don't need no stinking test vector.", 
                message = "Yes you do."),
         answer("Yes, we can reuse the vector named x.", correct=TRUE),
         allow_retry = TRUE,
         random_answer_order = TRUE)
```

###

* Write a piece of code that uses `max()` to double count the highest score in `x` and then takes the average of the 11 results.

```{r e3, exercise = TRUE, exercise.setup = "make-x"}
x
```

```{r e3-hint}
"Your code should retrun the answer 99.09091."
```

```{r e3-solution}
(sum(x) + max(x)) / 11
```

* Wrap your code in `function()` and save it to the name `grade2`.
* Then define the argument(s) for the function.

```{r e4, exercise = TRUE}
(sum(x) + max(x)) / 11
```

```{r e4-hint}
"When you use this workflow, the names of the argument(s) are always the names of the object(s) that you created in step 1."
```

```{r e4-solution}
grade2 <- function(x) {
  (sum(x) + max(x)) / 11
}
```

## Argument Specifications and Default Values

```{r quiz-3b}
quiz(
  question("Select all that apply: Which of the following operations requires running a function in R?",
           answer("Taking a log value", correct = TRUE),
           answer("Fitting a linear model", correct = TRUE),
           answer("Adding two numbers", correct = TRUE)),
  question("Which of the following statements is NOT true about providing values for formal arguments in functions?",
           allow_retry= TRUE,
           random_answer_order = TRUE,
           answer("Never does the order that you provide formal arguments matter", correct = TRUE),
           answer("It is best practice to explicitly write out each argument name followed by an equal sign and its value"),
           answer("If you leave out argument names, R will match your values to arguments in the order that they are listed"),
           answer("If you do not provide a value and the function contains a default value, the default value is used")),
  question("Which method(s) can you use to match values to arguments? (Check all that apply.)",
         answer("Complete names (e.g. na.rm = TRUE)", correct = TRUE),
         answer("Partial names (e.g. na = TRUE)", correct = TRUE),
         answer("Numbers (e.g. 2 = TRUE)"),
         answer("Position (e.g. TRUE)", correct = TRUE),
         allow_retry = TRUE, type = "multiple", 
         incorrect = "Did you check _every_ method that works?",
         correct = "Good job! R can match values to arguments in three ways, but some of these methods are more foolproof then others."))
```

###

What will the following code return?

```{r eval = FALSE, echo = TRUE}
f <- function(a, b, c) {
  a
  b
  c
}
f(1, 2, 3)
```

```{r quiz-2b}
question("",
         answer("1"),
         answer("2"),
         answer("3", correct =TRUE, message = "A function will return the result of its *last* line."),
         answer("A vector that contains 1, 2, and 3"),
         answer("An error"),
         allow_retry = TRUE)
```

###

It's time to put it all together. 

Use the code block below to develop a function named `l2` that calculates the Euclidean distance, or L~2~ norm ($\|x||_{2}$), of a vector of numbers named `x`. The L~2~ norm is the square root of the sum of the squared values in the vector, i.e.

$$\| x \|_{2} = \sqrt{\sum_{i = 1}^{n} x_{i}^{2}}$$

When you are finished, reduce your code to just the definition of your function.

```{r e5, exercise = TRUE}
```

```{r e5-hint}
"Consider using sqrt(), sum(), and ^2. Your code will work with vectors of any length."
```

```{r e5-solution}
l2 <- function(x) {
  sqrt(sum(x^2))
}
```

### Default Values and Argument Positions

Consider this brilliant function:

```{r}
foo <- function(aaa, abb, abc) {
  c(aaa, abb, abc)
}
```

```{r no-args, echo = FALSE}
question("What will `foo()` return?",
         answer('[1] "aaa" "abb" "abc"'),
         answer("An error", correct = TRUE, message = "`foo` will not be able to find a value for `aaa` (or the rest)."),
         allow_retry = TRUE)
```

Let's make `foo` even more brilliant:

```{r}
foo <- function(aaa = 1, abb = 2, abc = 3) {
  c(aaa, abb, abc)
}
```

```{r default-args}
quiz(
  question("Now what will `foo()` return?",
         answer('[1] "aaa" "abb" "abc"'),
         answer('[1] 1 2 3', correct = TRUE, message = "An argument with a default value is optional, R will use the default value if you do not provide one."),
         answer("An error"),
         allow_retry = TRUE),
question("Which of these could you run to see the names and default values of `foo`'s arguments?",
         answer("`foo`"),
         answer("`?foo`"),
         answer("`formals(foo)`"),
         answer("`args(foo)`"),
         answer("All of the above.", correct = TRUE, message = "Each of these will return output that contains `foo`'s argument names and default values (somewhere in the output)."),
         incorrect = "Is that the only way?",
         allow_retry = TRUE),
question("What will `foo(0)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 2 3", correct = TRUE, message = "If you do not provide an argument name in your call, R will match your value to the first unmatched argument name."),
         answer("[1] 1 0 3"),
         answer("[1] 1 2 0"),
         answer("[1] 0 0 0"),
         answer("An error"),
         allow_retry = TRUE),
question("What will `foo(0, 5)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 5 3", correct = TRUE, message = "I think you have the hang of position matching."),
         answer("[1] 0 5 0"),
         answer("[1] 0 5 5"),
         answer("An error"),
         allow_retry = TRUE),
question("What will `foo(aaa = 0, abc = 5)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 5 3"),
         answer("[1] 0 5 0"),
         answer("[1] 0 2 5", correct = TRUE, message = "Using complete argument names is the easiest way to avoid an error (and to write comprehensible code). But what if you use a partial argument name?"),
         answer("An error"),
         allow_retry = TRUE),
question("What will `foo(aa = 0)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 2 3", correct = TRUE, message = "You do not need to spell out the full argument name, so long as you provide enough of the name to uniquely identify the argument. Here `aa` could only be the beginning of the `aaa` argument."),
         answer("[1] 0 0 0"),
         answer("An error"),
         allow_retry = TRUE),
question("What will `foo(a = 0)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 0 2 3"),
         answer("[1] 0 0 0"),
         answer("An error", correct = TRUE, message = "Here `a` does not uniquely match an argument name: it is the beginning of all three argument names. R isn't psychic, so it won't guess which argument you meant. Instead R returns an error. It's the right thing to do because it lets you fix your code."),
         allow_retry = TRUE))
```

###

Now for some dark magic:

```{r}
foodoo <- function(...) {
  c(...)
}
```

```{r dots-1, echo = FALSE}
quiz(
  question("What will `foodoo(1, 2, 3)` return?",
         answer("[1] 1 2 3", correct = TRUE, message = "`...` is a special mechanism for passing arguments. `...` will match any argument not otherwise matched and pass those arguments on as a group. This is a convenient way to pass a set of arguments through to a function in the function body."),
         answer("An error."),
         answer("Oh my goodness! You've broken R!"),
         allow_retry = TRUE),
question("What will `foodoo(a = 1, b = 2, c = 3)` return?",
         answer("[1] 1 2 3"),
         answer("[1] 1 2 3 _but with the names a b c above the values_", correct = TRUE, message = "If you provide names to your values, `...` will capture those as well and pass them on. So here, our code essentially runs `c(a = 1, b = 2, c = 3)`."),
         answer("An error."),
         allow_retry = TRUE))
```

###  

Here is one last wrinkle. Suppose we rewrite `foodoo` slightly:

```{r}
foodoo <- function(a, ...) {
  c(...)
}
```

```{r dots-3, echo = FALSE}
quiz(
  question("What will `foodoo(a = 1, b = 2, c = 3)` return?",
         answer("[1] 1 2 3 with the names a b c above the values"),
          answer("[1] 2 3 with the names b c above the values", correct = TRUE, message = "Remember that `...` only captures _unmatched_ values. Now that `a` is a formal argument, `a = 1` will be matched to it, leaving `b = 2` and `c = 3` to be captured and passed on."),
         answer("An error."),
         allow_retry = TRUE))
```

## Formal Testing

### Checks using `stopifnot()`, and `stop()`

<!-- EC: Need more stopifnot() questions -->

```{r echo=TRUE, eval=FALSE}
impatient_square <- function(x) {
  return(x)
  x^2
}
```

```{r return-quiz, echo = FALSE}
quiz(
  question("Which value will `impatient_square(2)` return?",
         answer("2", correct = TRUE, message = "R stops executing `impatient_square()` and returns `x` when R encounters `return(x)`. It doesn't matter that `return(x)` is not the last line of the function."),
         answer("4", message = "R stops executing `impatient_square()` when it encounters `return(x)`. As a result, R does not evaluate `x^2`."),
         allow_retry = TRUE),
  question("When should you use return()?",
           answer("Whenever you want your function to return a value from the last line of the code body", message = "Remember, R functions automatically return the last value."),
           answer("Whenever you want to return a value that is not the last line of the code body", correct = TRUE, message = "Correct! This can either be for diagnosis purposes when debugging or for unusual control flow cases in general"),
           allow_retry = TRUE))
```

###

```{r eval = FALSE, echo=TRUE}
immovable_square <- function(x) {
  stop("I refuse to proceed.")
  x^2
}
```

```{r stop-quiz}
quiz(
  question("What does `immovable_square(2)` return?",
         answer("4", message = 'R will stop executing `immovable_square()` and throw an error when it comes to `stop("I refuse to proceed.")`.'),
         answer("Error in immovable_square(2) : I refuse to proceed.", correct = TRUE, message = 'R will stop executing `immovable_square()` and throw an error when it comes to `stop("I refuse to proceed")`. The error message will look just like this answer; R inserts the message that you pass as a character string to `stop()`.'),
         allow_retry = TRUE))
```

### Combining Checks and Conditional Functions

```{r if-quiz, echo = FALSE}
question("Which describes `if`'s behavior? (Check all that apply).",
         answer("`if` takes a logical test and a piece of code. It runs the code _if_ the test returns TRUE.", correct = TRUE, message = "`if` is a way to run code only in certain cases. When you use `if`, you first pass it a logical test surrounded by parentheses and then a piece of code."),
         answer("`if` takes a logical test and a piece of code. It does not run the code _if_ the logical test returns FALSE.", correct = TRUE, message = "`if` will run the piece of code if the logical test returns TRUE and not run the code if the logical test returns FALSE."),
         answer("`if` returns the results of the code that appears in _parentheses_ behind `if`."),
         answer("`if` always executes all of the code that follows it.", message = "`if` will always execute the logical test that appears in parentheses behind `if`. However, `if` will only execute the code that appears after the logical test if the logical test returns TRUE."),
         allow_retry = TRUE)
```

Many data sets use their own symbols to represent missing values. For example, NOAA will often use -99 to represent missing values in weather data sets. Let's write a function that checks whether a value is -99, and if so replaces the value with NA, like this:

```{r echo = FALSE}
clean <- function(x) {
  if (x == -99) x <- NA
  x
}
```

```{r}
clean(1)
clean(-99)
```

###  

Add an `if` statement to the beginning of `clean()`. Your statement should assign NA to x if x equals -99.

```{r clean-setup}
x <- -99
```

```{r clean, exercise = TRUE}
clean <- function(x) {
  # add if statement here
  x
}
```

```{r clean-solution}
clean <- function(x) {
  if (x == -99) x <- NA
  x
}
```

```{r else-quiz, echo = FALSE}
question("Which describes `else`? (Check all that apply).",
         answer("R interprets `else` as a continuation of the `if` statement that immediately precedes it.", correct = TRUE, message = "`else` always follows an `if` statement (if not, `else` returns an error), and R always sees the combined `if` and `else` statements as a single statement."),
         answer("Unlike `if`, `else` does not take a logical test.", correct = TRUE),
         answer("Like `if`, `else` takes a piece of code.", correct = TRUE),
         answer("`else` executes the piece of code if the `if` condition returns FALSE.", correct = TRUE),
         answer("`else` does not execute the piece of code if the `if` condition returns TRUE.", correct = TRUE, message = "Think of a combined `if` `else` statement as a complete description: if the logical test at the start of the statement returns TRUE, R will run the code that follows `if` (but not the code that follows `else`). If the condition returns FALSE, R will run the code that follows `else` (but not the code that follows `if`)."),
         allow_retry = TRUE)
```

### Combining `stopifnot()` and  conditional statements

Use `if` and `is.null()` to add a `stop()` call at the beginning of `clean()`. The command should return the error message `"x is NULL"` whenever x is NULL. 

```{r stop, exercise = TRUE}
clean <- function(x) {
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stop-solution}
clean <- function(x) {
  if (is.null(x)) stop("x is NULL")
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stopifnot-quiz, echo = FALSE}
quiz(
  question('Which of these does the equivalent of `if (x < 0) stop("x is less than zero")`?',
         answer('`stopifnot(x < 0)`', message = "Good guess! But the function isn't called `stopif()`; it's called `stopifnot()`."),
         answer('`stopifnot(x >= 0)`', correct = TRUE, message = "`stopifnot()` stops if a condition is _not_ met, which is slightly different than `if` + `stop()`."),
         allow_retry = TRUE),
  question("How is stopifnot() different from if` + stop()?",
           allow_retry = TRUE,
           random_answer_order = TRUE,
           answer("Instead of checking whether a condition is met, `stopifnot()` checks whether a condition is not met", correct = TRUE),
           answer("stopifnot() always passes along a custom error message"),
           answer("stopifnot() cannot take logical arguments")))
```

###  

Replace the `if` + `stop()` statement in `clean()` with `stopifnot()`. 

```{r stopifnot, exercise = TRUE}
clean <- function(x) {
  if (is.null(x)) stop("x is NULL")
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

```{r stopifnot-solution}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  if (x == "NaN") return(NA)
  x
}
```

###

Rewrite the below function using `case_when()`.

```{r echo = TRUE}
foo <- function(x) {
  if (x > 2) "a"
  else if (x < 2) "b"
  else if (x == 1) "c"
  else "d"
}
```

```{r foo_rewrite, exercise = TRUE}
foo2 <- function(x) {
  case_when(
    
    # Insert code here!
    
  )
}
```

```{r foo_rewrite-hint-1}
foo2 <- function(x) {
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    ...
  )
}
```

```{r foo_rewrite-hint-2}
foo2 <- function(x) {
  case_when(
    x > 2  ~ "a",
    x < 2  ~ "b",
    x == 1 ~ "c",
    TRUE ~ ...
  )
}
```

###

Rewrite the multi-part version of `clean()` to use `case_when()`, which will allow `clean()` to handle vectors. Retain each case. Assume where necessary that `clean()` will only work with real numbers.

```{r when, exercise = TRUE}
clean <- function(x) {
  if (x == -99) NA 
  else if (x == ".") NA
  else if (x == "") NA
  else if (x == "NaN") NA
  else x
}
```

```{r when-hint}
clean <- function(x) {
  case_when(
    x == -99 ~ NA_real_, 
    x == "." ~ NA_real_,
    x == "" ~ NA_real_,
    x == "NaN" ~ NA_real_,
    TRUE ~ ...
  )
}
```

###

```{r eval = FALSE, echo = TRUE}
foo <- function(x) {
  if (x > 2) "a"
  else if (x < 2) "b"
  else if (x == 1) "c"
  else "d"
}
foo(1)
```

```{r else-if-quiz, echo = FALSE}
quiz(
  question("What will this code return?",
         answer('"a"', message = "R will not return a because the condition 1 > 2 is false."),
         answer('"b"', correct = TRUE, message = 'The condition 1 < 2 is true, so R will evaluate the code that follows it (i.e. "b") and then skip the remainder of the multi-part if statement.'),
         answer('"a" "b"', message = "The conditions 1 < 2 and 1 == 1 are both TRUE, but R will stop after the _first_ true condition."),
         allow_retry = TRUE))
```

###

```{r eval = FALSE, echo=TRUE}
clean <- function(x) {
  if (x == -99) NA 
  if (x == ".") NA
  if (x == "NaN") NA
  x
}
clean(-99)
```

```{r clean3-quiz, echo = FALSE}
quiz(
  question("What will this code return?",
         answer("NA", message = "Did you notice that the `if` statements are not linked by `else`? What difference does this make?"),
         answer("-99", correct = TRUE, message = "Since the `if` clauses are not linked by `else`, R treats them as separate statements. R checks each if statement. After the first statement it runs NA, but does not return this as the result of the function (because this is not the final statement in the function). R does not run NA for the next two if statements because their conditions are false. Then R reaches `x`, which is the last line and last statement in the function. R evaluates `x`, which equals -99, and returns -99 as the result of the function."),
         allow_retry = TRUE))
```


Replace the two `if` statements below with a single statement that tests whether x is `-99` or `"."` without throwing error messages.

```{r or, exercise = TRUE}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99) return(NA)
  if (x == ".") return(NA)
  x
}
```

```{r or-solution}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99 || x == ".") return(NA)
  x
}
```

###  

```{r eval = FALSE, echo= TRUE}
clean <- function(x) {
  stopifnot(!is.null(x))
  if (x == -99 || x == ".") return(NA)
  x
}
```

```{r vector-quiz, echo = FALSE}
question("What will `clean(c(-99, 0, 1))` return?",
         answer("NA 0 1", message = "The logical test will only consider the first value of the vector x, which here contains c(-99, 0, 1). Since that value is -99, the logical test will return TRUE and R will execute the code `return(NA)`, which returns a single NA."),
         answer("NA _with_ a warning message", message = "You certainly would get a warning message if your logical test used |, which will pass a vector of TRUEs and FALSEs to if, triggering the message. However, || will only pass on a single TRUE or FALSE."),
         answer("NA _without_ a warning message", correct = TRUE),
         answer("an error"),
         allow_retry = TRUE)
```

## Using custom and anonymous functions with `map_*` functions and list-columns

Explore the `airquality` dataset using `skim()`.

```{r exercise-1a, exercise = TRUE}

```

```{r exercise-1a-hint}
skim(...)
```

Create a list-column of monthly temperatures called `monthly_temp`, grouping by `Month`.

```{r exercise-2a, exercise = TRUE}

```

```{r exercise-2a-hint}
airquality %>%
   group_by(Month) %>%
   mutate(monthly_temp = list(...))
```

###

```{r echo=TRUE, eval=FALSE}
airquality %>%
   group_by(Month) %>%
   mutate(monthly_temp = list(Temp)) %>%
   mutate(celsius = map(fahrenheit, ...)
```

```{r quiz-4}
quiz(caption = "",
  question("Which of the following possibilities for filling in the blank is syntactically correct and converts from Fahrenheit to Celsius?",
           answer("(. - 32) * 5/9)"),
           answer("- 32 * 5/9"),
           answer("~ (. - 32) * 5/9)", correct = TRUE),
           answer("~ (fahrenheit - 32) * 5/9)"))
)
```

###

Use a `map_*` function to convert all of the temperatures in `monthly_temp` from Fahrenheit to Celsius, creating a new variable `temp_celsius`. Hint: Use the formula from the quiz above!

```{r exercise-3a, exercise = TRUE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(...)
```

```{r exercise-3a-hint}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ...))
```

Oops! The scientists made a mistake in which all of the temperatures were misrecorded. For temperatures recorded at or below 20 degrees Celsius, the true temperature is actually 1 degree Celsius lower. For temperatures recorded as higher than 20 degrees Celsius, the true temperature is actually 3 degrees Celsius higher.

Write an anonymous function using base R that rectifies the scientists' mistake using `case_when()`.

```{r exercise-4a, exercise=TRUE}
function(x) 
  case_when(...)
```

```{r exercise-4a-solution}
function(x) 
  case_when(x <= 20 ~ x - 1,
            x > 20 ~ x + 3)
```

###

Now use this function along with `map()`, swapping out the base R for the `~` in the `map()` argument.

```{r exercise-5a, exercise=TRUE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ ...))
```

```{r exercise-5a-hint}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ case_when(...)))
```

###

Now let's get a sense of the "corrected" data. Sort the temperatures from coldest to hottest each month.

```{r exercise-6a, exercise=TRUE}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ case_when(. <= 20 ~ . - 1,
            . > 20 ~ . + 3)))
```

```{r exercise-6a-solution}
airquality %>%
  group_by(Month) %>%
  mutate(monthly_temp = list(Temp)) %>%
  mutate(temp_celsius = map(monthly_temp, ~ (. - 32)* 5/9)) %>%
  mutate(temp_celsius = map(temp_celsius, ~ sort(case_when(. <= 20 ~ . - 1,
            . > 20 ~ . + 3))))
```

```{r quiz-5}
quiz(
  question("What is the coldest temperature in July?",
           answer("25.78 degrees Celsius", correct = TRUE, message = "Great job! Now let's move on to another practice exercise."),
           answer("30.33 degrees Celsius"),
           answer("12.33 degrees Celsius"),
           answer("26.33 degrees Celsius"))
)
```

###

Let's say you are trying to create a function, `coin_flip()`, that takes an input `n` of the number of times to flip a coin and adds up the number of Tails.

Let's start by creating a minimally viable function called `starter_coin()` that flips one coin once and prints out `H` or `T`. Remember: You can paste vectors as an argument into `sample()`!

```{r coin1, exercise=TRUE}

```

```{r coin1-hint}
starter_coin <- function() sample(c("H", "T"), ...)
```

###

Now let's take it up a notch and add in a formal argument `n` that specifies the number of times to flip the coin.

```{r coin2, exercise=TRUE}

```

```{r coin2-hint}
starter_coin <- function(n) sample(c("H", "T"), n, replace = ...)
```

###

Add in a sensible `stopifnot()` to your function that checks whether the input `n` is numeric.

```{r coin3, exercise=TRUE}

```

```{r coin3-hint}
starter_coin <- function(n) {
  stopifnot(is.numeric(...))
  sample(c("H", "T"), n, replace = TRUE)
}
```

###

Great! Now we should be able to create `coin_flip()`, which counts the number of Tails for `n` flips. Set the default value of `n` to 1.

```{r coin4, exercise=TRUE}
coin_flip <- function(n = 1) {
  ...
}
```

```{r coin4-hint-1}
# Use the code from starter_coin() and sum().
```

```{r coin4-hint-2}
coin_flip <- function(n = 1) {
  stopifnot(is.numeric(n))
  sum(sample(c("H", "T"), n, replace = TRUE) == ...)
}
```

###

Now let's create a function called `five_flips` that counts how many Tails occur in five coin flips, or the equivalent of `coin_flip(5)`, but calls it `n` times.
* Set the default value of `n` separate flips to 1.
* Use a `map_*` function to apply the `rep()` function to `coin_flip()` `n` times.

```{r coin5, exercise=TRUE}
five_flips <- function(n = 1) {
  ...
}
```

```{r coin5-hint-1}
# The map function you are looking for is map_int().
```

```{r coin5-hint-2}
# rep(x,n) means that you are flipping x coins n times.
```

```{r coin5-hint-3}
five_flips <- function(n = 1) {
  stopifnot(is.numeric(n))
  map_int(rep(5, n), ...)
}
```

###

Create a tibble named `x` with one variable: `flips`. `flips` is a list column of 10 observations, each element of which is result of flipping 5 coins 10 times. 

```{r coin-quiz}
quiz(
  question("Select all that apply: Which of the following is equivalent to flipping 5 coins 10 times?",
           answer("five_flips(10)", correct = TRUE, message = "Use this function for the next exercise!"),
           answer("five_flips(5, 10)"),
           answer("five_flips(5)"),
           allow_retry = TRUE,
           random_answer_order = TRUE))
```

Create `x` as specified above. Make sure to use the correct `map_*` function.

```{r coin7, exercise=TRUE}
x <- tibble(flips = ...)
```

```{r coin7-hint}
x <- tibble(flips = map(rep(10, 10), ...))
```

###

Now we are interested in finding the `mean()`, `min()`, and `max()` of each row. Use the appropriate `map_*` functions to create new columns named `average`, `minimum`, and `maximum`, using the aforementioned functions respectively.

```{r coinsetup}
x <- tibble(flips = map(rep(10, 10), five_flips))
```

```{r coin8, exercise=TRUE, exercise.setup = "coinsetup"}
x %>%
  mutate(...)
```

```{r coin8-hint}
x %>%
  mutate(average = map_dbl(...),
         minimum = map_dbl(...),
         maximum = map_dbl(...))
```

###

That seems kind of clunky to create three new columns. What if I wanted to return a single new list-column named `descriptive_stats` that contained a list of the mean, minimum, and maximum values? Time to write a function!

```{r coin9setup, exercise.setup = "coinsetup"}
stat_ops <- function(x) {
  a <- mean(x)
  b <- min(x)
  c <- max(x)
  return(c(a,b,c))
}
```

```{r coin9, exercise = TRUE, exercise.setup = "coin9setup"}
x %>%
   mutate(descriptive_stats = ...)
```

```{r coin9-hint}
x %>%
   mutate(descriptive_stats = map(flips, ...))
```

## Submit

```{r encode, echo=FALSE}
learnrhash::encoder_ui(
  ui_before = shiny::div(
    "When you have completed this tutorial, follow these steps:",
        br(),
    tags$ol(
       tags$li("Click Generate Submission"),
       tags$li("Copy and paste the hash generated into the \"Hash\" textbox"),
       tags$li("Press 'Create responses.rds'. Nothing will pop up, but this will create an .rds file of your hashed responses."),
       tags$li("Download the .rds file. A window will pop up asking you where to place the downloaded file. Upload this file to the appropriate Canvas assignment."))
  )
)
```

```{r context="setup"}
fluidPage(
    mainPanel(
          div(id = "form",
            textInput("hash", "Hash", ""),
            actionButton("submit", "Create responses.rds", class = "btn-primary"),
            downloadButton("downloadData", "Download responses.rds")
          )
        )
    )
```

```{r context="server"}

learnrhash::encoder_logic()

 observeEvent(input$submit,{
        hash_id <<- input$hash
        responses <<- data.frame("Hash" = hash_id)
 })
output$downloadData <- downloadHandler(
      filename = "responses.rds",
      content = function(file) {
      write_rds(responses, file)
    }
  )
```
